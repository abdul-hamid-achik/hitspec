package proxy

import (
	"encoding/json"
	"fmt"
	"sort"
	"strings"
)

// ExportRecordings exports recordings to hitspec format
func ExportRecordings(recordings []Recording) string {
	var sb strings.Builder

	sb.WriteString("# Recorded API requests\n")
	sb.WriteString("# Generated by hitspec record\n\n")

	for i, rec := range recordings {
		// Request separator with name
		name := generateName(rec.Method, rec.Path)
		sb.WriteString("### ")
		sb.WriteString(name)
		sb.WriteString("\n")

		sb.WriteString("# @name ")
		sb.WriteString(sanitizeExportName(name))
		sb.WriteString("\n")

		// Method and URL
		sb.WriteString(rec.Method)
		sb.WriteString(" ")
		sb.WriteString(rec.URL)
		sb.WriteString("\n")

		// Headers (sorted for consistency)
		headers := sortedHeaders(rec.Headers)
		for _, h := range headers {
			// Skip common auto-generated headers
			if shouldSkipHeader(h.key) {
				continue
			}
			sb.WriteString(h.key)
			sb.WriteString(": ")
			sb.WriteString(h.value)
			sb.WriteString("\n")
		}

		// Body
		if rec.Body != "" {
			sb.WriteString("\n")
			sb.WriteString(formatBody(rec.Body, rec.ContentType))
			sb.WriteString("\n")
		}

		// Assertions based on response
		if rec.Response != nil {
			sb.WriteString("\n>>>\n")
			sb.WriteString(fmt.Sprintf("expect status == %d\n", rec.Response.StatusCode))

			// Add content-type assertion if JSON
			if strings.Contains(rec.Response.ContentType, "json") {
				sb.WriteString("expect header Content-Type contains application/json\n")

				// Try to generate basic body assertions
				bodyAssertions := generateBodyAssertions(rec.Response.Body)
				if bodyAssertions != "" {
					sb.WriteString(bodyAssertions)
				}
			}

			sb.WriteString("<<<\n")
		}

		if i < len(recordings)-1 {
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

func generateName(method, path string) string {
	// Convert path to a readable name
	// /api/users/123 -> Get User 123
	// /api/products -> List Products

	parts := strings.Split(strings.Trim(path, "/"), "/")
	if len(parts) == 0 {
		return method + " Root"
	}

	// Remove common prefixes
	if len(parts) > 0 && (parts[0] == "api" || parts[0] == "v1" || parts[0] == "v2") {
		parts = parts[1:]
	}

	// Build name
	var name strings.Builder

	// Add method prefix based on HTTP method
	switch strings.ToUpper(method) {
	case "GET":
		if len(parts) > 1 && !strings.Contains(parts[len(parts)-1], "{") {
			name.WriteString("Get ")
		} else {
			name.WriteString("List ")
		}
	case "POST":
		name.WriteString("Create ")
	case "PUT":
		name.WriteString("Update ")
	case "PATCH":
		name.WriteString("Patch ")
	case "DELETE":
		name.WriteString("Delete ")
	default:
		name.WriteString(method)
		name.WriteString(" ")
	}

	// Add resource name
	for i, part := range parts {
		if strings.HasPrefix(part, "{") || isNumeric(part) {
			continue
		}
		if i > 0 {
			name.WriteString(" ")
		}
		name.WriteString(capitalize(part))
	}

	return name.String()
}

func sanitizeExportName(name string) string {
	result := strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') {
			return r
		}
		return '_'
	}, name)

	// Remove consecutive underscores and trim
	for strings.Contains(result, "__") {
		result = strings.ReplaceAll(result, "__", "_")
	}
	return strings.Trim(result, "_")
}

type headerPair struct {
	key   string
	value string
}

func sortedHeaders(headers map[string]string) []headerPair {
	var pairs []headerPair
	for k, v := range headers {
		pairs = append(pairs, headerPair{k, v})
	}
	sort.Slice(pairs, func(i, j int) bool {
		return pairs[i].key < pairs[j].key
	})
	return pairs
}

func shouldSkipHeader(header string) bool {
	skipHeaders := []string{
		"Host",
		"Content-Length",
		"Accept-Encoding",
		"Connection",
		"User-Agent",
	}

	for _, skip := range skipHeaders {
		if strings.EqualFold(header, skip) {
			return true
		}
	}
	return false
}

func formatBody(body, contentType string) string {
	if strings.Contains(contentType, "json") {
		// Try to pretty-print JSON
		var data interface{}
		if err := json.Unmarshal([]byte(body), &data); err == nil {
			if pretty, err := json.MarshalIndent(data, "", "  "); err == nil {
				return string(pretty)
			}
		}
	}
	return body
}

func generateBodyAssertions(body string) string {
	if body == "" {
		return ""
	}

	var data interface{}
	if err := json.Unmarshal([]byte(body), &data); err != nil {
		return ""
	}

	var sb strings.Builder

	switch v := data.(type) {
	case map[string]interface{}:
		// Generate assertions for top-level keys
		for key := range v {
			sb.WriteString(fmt.Sprintf("expect body.%s exists\n", key))
		}
	case []interface{}:
		sb.WriteString("expect body type array\n")
		if len(v) > 0 {
			sb.WriteString(fmt.Sprintf("expect body length >= %d\n", len(v)))
		}
	}

	return sb.String()
}

func capitalize(s string) string {
	if len(s) == 0 {
		return s
	}
	// Simple capitalize: uppercase first letter
	first := strings.ToUpper(string(s[0]))
	if len(s) == 1 {
		return first
	}
	return first + s[1:]
}

func isNumeric(s string) bool {
	for _, c := range s {
		if c < '0' || c > '9' {
			return false
		}
	}
	return len(s) > 0
}
